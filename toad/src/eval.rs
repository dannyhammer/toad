/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

use std::marker::PhantomData;

use crate::{Color, Piece, Score, Square, Variant};

// Include the eval params that have been generated by the tuner
// include!(concat!(env!("OUT_DIR"), "/eval_params.rs"));
include!("tuned_eval_params.rs");

#[derive(Debug, Default, PartialEq, Eq, Clone, Copy)]
pub struct Evaluator<V> {
    /// Material remaining on the board, for each side.
    pub(crate) material: [i32; Color::COUNT],

    /// Mid-game and end-game evaluations of the board.
    pub(crate) evals: (Score, Score),

    /// Variant of chess being played.
    variant: PhantomData<V>,
}

impl<V: Variant> Evaluator<V> {
    /// Construct a new [`Evaluator`] instance.
    #[inline(always)]
    pub const fn new() -> Self {
        Self {
            material: [0; Color::COUNT],
            evals: (Score::DRAW, Score::DRAW),
            variant: PhantomData,
        }
    }

    /// Evaluate this position from `color`'s perspective.
    ///
    /// A positive/high number is good for the `color`, while a negative number is better for the opponent.
    /// A score of 0 is considered equal.
    #[inline(always)]
    pub fn eval_for(&self, color: Color) -> Score {
        self.evals.0.lerp(self.evals.1, self.endgame_weight()) * color.negation_multiplier() as i32
    }

    /// Divides the original material value of the board by the current material value, yielding an `i32` in the range `[0, 100]`
    ///
    /// Lower numbers are closer to the beginning of the game. Higher numbers are closer to the end of the game.
    ///
    /// The King is ignored when performing this calculation.
    #[inline(always)]
    pub fn endgame_weight(&self) -> i32 {
        let remaining = V::INITIAL_MATERIAL_VALUE - self.material_remaining();
        (remaining * 100 / V::INITIAL_MATERIAL_VALUE * 100) / 100
    }

    /// Returns the current mid-game and end-game evaluations.
    #[inline(always)]
    pub fn evals(&self) -> (Score, Score) {
        self.evals
    }

    /// Called when a piece is placed on a square to update the eval of the board.
    #[inline(always)]
    pub(crate) fn piece_placed(&mut self, piece: Piece, square: Square) {
        let color = piece.color();
        let multiplier = color.negation_multiplier() as i32;

        self.material[color] += piece.kind().value();

        // Update PSQT contributions
        let (mg, eg) = psqt_evals(piece, square);
        self.evals.0 += mg * multiplier;
        self.evals.1 += eg * multiplier;
    }

    /// Called when a piece is removed from a square to update the eval of the board.
    #[inline(always)]
    pub(crate) fn piece_taken(&mut self, piece: Piece, square: Square) {
        let color = piece.color();
        let multiplier = color.negation_multiplier() as i32;

        self.material[piece.color()] -= piece.kind().value();

        // Update PSQT contributions
        let (mg, eg) = psqt_evals(piece, square);
        self.evals.0 -= mg * multiplier;
        self.evals.1 -= eg * multiplier;
    }

    /// Counts the material value of all pieces on the board
    ///
    /// The King is not included in this count
    #[inline(always)]
    fn material_remaining(&self) -> i32 {
        self.material[Color::White.index()] + self.material[Color::Black.index()]
    }
}

/// Fetch the mid-game and end-game evaluations for a `piece` at `square`
/// through the use of [Piece-Square Tables](https://www.chessprogramming.org/Piece-Square_Tables).
#[inline(always)]
pub fn psqt_evals(piece: Piece, square: Square) -> (Score, Score) {
    // Get the rank-relative square for this piece
    let square = square.rank_relative_to(piece.color().opponent());

    // Fetch the mid-game and end-game PSQTs and piece values
    let (mg_psqt, eg_psqt) = TUNED_PSQT[piece.kind()];
    let (mg_val, eg_val) = TUNED_PIECE_VALUES[piece.kind()];

    // Return the computed scores
    (
        Score::new(mg_psqt[square] + mg_val),
        Score::new(eg_psqt[square] + eg_val),
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::PieceKind;

    #[test]
    fn test_eval_is_correct_for_colors() {
        // Over every possible square
        for square in Square::iter() {
            // For every piece
            for kind in PieceKind::all() {
                // Assert that White's PSQT eval is equal to Black's equivalent PSQT eval
                let white = psqt_evals(Piece::new(Color::White, kind), square);
                let black = psqt_evals(
                    Piece::new(Color::Black, kind),
                    square.rank_relative_to(Color::Black),
                );

                assert_eq!(
                    white,
                    black,
                    "{} on {square}: {white:?} (white) != {black:?} (black)",
                    kind.name()
                );
            }
        }
    }
}
